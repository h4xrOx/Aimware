local ffi=ffi;local bit=bit;local a=table.new;local b=table.clear;local c,d,e,f,g,h,i,j,k,l,m=string.format,table.insert,bit.band,bit.rshift,bit.lshift,string.char,coroutine.yield,ffi.new,ffi.copy,ffi.fill,ffi.string;local n=ffi.typeof("uint8_t[?]")local o=ffi.typeof("int[?]")if not pcall(ffi.sizeof,"gif_rgba")then ffi.cdef("typedef union { uint32_t all; struct { uint8_t r, g, b, a; }; } gif_rgba;")ffi.cdef("typedef struct { uint8_t r,g,b; } gif_rgb;")end;local p=ffi.typeof("gif_rgba")local q=ffi.typeof("gif_rgba[?]")local r=ffi.typeof("const gif_rgb *")local s={0,8,4,8,2,4,1,2,false}local t="GIF87a"local u="GIF89a"local v=0x3B;local w=0x2C;local x=0x21;local y=0xFF;local z=0xF9;local A=0x01;local B=0xFE;local C=j(p)local function D(self,E)local F=self.baseva+self.seekpos;local G=self.endva-F;if E>G then return error("tried to read past end")end;local H=self.seekpos;self.seekpos=H+E;return H end;local function I(self)return self.baseva[D(self,1)]end;local function J(self)self.baseva=nil;self.endva=nil;self.contents=nil;self.ncomplete=nil;self.duration=0;for K=1,#self.frames do self.duration=self.duration+self.frames[K][2]end end;local function L(M,N,O)local P=ffi.cast(r,N)for K=0,O-1 do M[K].r=P[K].r;M[K].g=P[K].g;M[K].b=P[K].b;M[K].a=255 end end;local function Q(self)if#self.contents<13 then return"Invalid GIF file format"end;local R=self.contents:sub(1,6)D(self,13)if R~=t and R~=u then return"Invalid GIF file format"end;local S=self.baseva;local T,U=S[6]+256*S[7],S[8]+256*S[9]local V=T*U;local W=q(V)self.width,self.height=T,U;local X=S[10]>=128 and g(1,e(S[10],7)+1)or 0;local Y=S[11]self.aspect=((S[12]==0 and 49 or 0)+15)/64;local Z=q(256)local _=q(256)local a0,a1;if X>0 then D(self,X*3)L(Z,S+13,X)if Y<X then a1=p()a1.r=Z[Y].r;a1.g=Z[Y].g;a1.b=Z[Y].b end end;local a2;local a3=false;local a4=0;local a5=0;local a6=n(4096)local a7=o(4096)local a8=n(4096)if a1~=nil and a1.a>0 then for K=0,V-1 do W[K].all=a1.all end end;while true do local a9=I(self)local aa;if a9==w then a9=w elseif a9==x then a9=I(self)if a9==w then break end elseif a9~=v then return c("Unknown block type: 0x%02X",a9)end;if a9==v then break elseif a9==y then aa=I(self)a2=D(self,aa+1)if aa>=11 and ffi.string(S+a2,11)=="NETSCAPE2.0"then a2=a2+aa;while S[a2]~=0 do local ab=S[a2]a2=D(self,ab+1)if S[a2]==1 and ab>=3 then self.loop=S[a2+1]+256*S[a2+2]end;a2=a2+ab end else a2=a2+aa;while S[a2]~=0 do D(self,S[a2])a2=D(self,1)end end elseif a9==A or a9==B then a2=D(self,1)if a9<A then a2=D(self,S[a2]+1)+S[a2]a3=false;a4=0;a5=0 end;while S[a2]~=0 do a2=D(self,S[a2]+1)+S[a2]end elseif a9==z then a2=D(self,1)aa=S[a2]a2=D(self,aa+1)if aa>=4 then a5=(S[a2+1]+256*S[a2+2])/100;a3=e(S[a2],1)~=0 and S[a2+3]a4=f(e(S[a2],0x1C),2)if a5==0 then a5=0.1 end end;a2=a2+aa;while S[a2]~=0 do a2=D(self,S[a2]+1)+S[a2]end elseif a9==w then a2=D(self,9)local ac,ad=S[a2]+256*S[a2+1],S[a2+2]+256*S[a2+3]local ae,af=S[a2+4]+256*S[a2+5],S[a2+6]+256*S[a2+7]if ae==0 or af==0 then return"Zero size image"end;d(self.frames,{a4,a5,ac,ad,ae,af})local ag,ah,ai,aj=ac,ad,ae,af;local ak=ag~=0 or ah~=0 or ai~=T or aj~=U;local al=S[a2+8]if al>=128 then a0=g(1,e(al,7)+1)a2=D(self,a0*3)L(_,S+a2,a0)else k(_,Z,X*4)a0=X end;if a3 and a3<a0 then _[a3].all=0 end;local am=e(al,64)~=0 and 1;a2=D(self,2)local an=S[a2]a2=a2+1;if an==0 or an>11 then return"Invalid code size"end;local ao=an+1;local ap=g(1,an)local aq=ap+2;local ar,as=0,0;ac,ad=0,0;local at=a2;local au;local av;local aw=0;local ax=T*ah+ag;while true do if as>=ao and ad then local ay=e(ar,g(1,ao)-1)ar=f(ar,ao)as=as-ao;if ay==ap then ao=an+1;aq=ap+2;au=false elseif ay==ap+1 then if ac~=0 or aw~=af then return"Soft EOD before all rows were output"end;ad=false else local az=4095;if ay<aq then av=ay;while av>=ap do a8[az]=a6[av]az=az-1;av=a7[av]end;a8[az]=av;if au then if aq<4096 then a7[aq]=au;a6[aq]=av;aq=aq+1;if aq~=4096 and e(aq,aq-1)==0 then ao=ao+1 end end end;au=ay else if ay>aq or not au or not av then return"Broken LZW"end;if au then if aq<4096 then a7[aq]=au;a6[aq]=av;aq=aq+1;if aq~=4096 and e(aq,aq-1)==0 then ao=ao+1 end end end;au=ay;av=au;while av>=ap do a8[az]=a6[av]az=az-1;av=a7[av]end;a8[az]=av end;if ad then for K=az,4095 do local aA=a8[K]if aA>=a0 then aA=0 end;local aB=_[aA]if a4~=1 or aB.all>0 then aA=aB;W[ax+ac]=aA;if(ag>0 or ah>0)and am then return"Interlaced + frame compressed gifs not supported"end end;if am then if aA and self.progressive and am<7 and ad+1<af then W[ax+ac+ae]=aA;if am<5 and ad+2<af then W[ax+ac+ae*2]=aA;if ad+3<af then W[ax+ac+ae*3]=aA;if am<3 and ad+4<af then W[ax+ac+ae*4]=aA;if ad+5<af then W[ax+ac+ae*5]=aA;if ad+6<af then W[ax+ac+ae*6]=aA;if ad+7<af then W[ax+ac+ae*7]=aA end end end end end end end;ac=ac+1;if ac>=ae then ac=0;aw=aw+1;ad=ad+s[am+1]if ad>=af then am=am+2;if am>7 then ad=false else ad=s[am]end end;if ad then ax=ad*ae+(ak and T*ah+ad*(T-ai)+ag or 0)end end else ac=ac+1;if ac>=ae then ac=0;ad=ad+1;aw=ad;if ad>=af then ad=false else ax=ad*ae+(ak and T*ah+ad*(T-ai)+ag or 0)end end end end else return"Data past the end of the image"end end else if a2>=at then local ab=S[at]if ab==0 then if ad then return"Hard EOD before the end of the image"end;break end;a2=D(self,ab+1)at=a2+ab end;if ad then ar=ar+g(S[a2],as)as=as+8;a2=a2+1 else a2=at end end end;local aC=m(W,V*4)local aD=draw.CreateTexture(aC,T,U)if aD==nil then return c("Failed to load frame %d",#self.frames)end;d(self.frames[#self.frames],aD)if a4==0 then l(W,V*4,0)elseif a4==1 then elseif a4==2 then if a1~=nil then if a1.all==0 then l(W,V*4,0)else for K=0,V-1 do W[K].all=a1.all end end else return"Dispose mode 2, but no background given"end else return c("Unsupported dispose mode: %d",a4)end;a3=false;a4=0;a5=0;self.ncomplete=#self.frames else break end end end;local function aE(self,aF)if self.frames[aF]==nil then error("Frame not found",2)end;local aG,aH,ac,ad,ae,af,aD=unpack(self.frames[aF])return aD,ac,ad,ae,af,aG,aH end;local function aI(self,aF,ac,ad,ae,af)if self.frames[aF]==nil then error("Frame not found",2)end;local aD=aE(self,aF)draw.SetTexture(aD)draw.FilledRect(ac,ad,ac+ae,ad+af)end;local function aJ(self,aK,...)if self.duration==0 then aK=0 else aK=aK%self.duration end;local aL,aF=0;for K=1,#self.frames do aL=aL+self.frames[K][2]if aL>=aK then aF=K;break end end;if aF==nil then error("Frame not found",2)end;return aI(self,aF,...)end;local aM={}local aN={__index={frame=aE,drawframe=aI,draw=aJ}}function aM.load_gif(aO)local aP={width=false,height=false,frames={},ncomplete=0,progressive=false,loop=false,aspect=false,baseva=ffi.cast("const uint8_t *",ffi.cast("const char *",aO)),endva=false,contents=aO,seekpos=0}aP.endva=aP.baseva+#aO;local aQ=Q(aP)J(aP)if aQ~=nil then return error(aQ,2)end;return setmetatable(aP,aN)end;return aM